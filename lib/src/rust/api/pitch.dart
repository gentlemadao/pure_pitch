// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `decode_and_resample`, `enforce_global_monophony`, `get_cached_or_decode`, `merge_note_events`, `preprocess_chunk`, `run_inference_internal`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

Future<void> clearAudioCache() =>
    RustLib.instance.api.crateApiPitchClearAudioCache();

Future<void> aecInit({
  required int sampleRate,
  required int numChannels,
  required List<String> referencePaths,
}) => RustLib.instance.api.crateApiPitchAecInit(
  sampleRate: sampleRate,
  numChannels: numChannels,
  referencePaths: referencePaths,
);

Future<void> aecReset() => RustLib.instance.api.crateApiPitchAecReset();

/// Initialize ORT environment.
/// Must be called before any other ORT operations.
///
/// [dylib_path] Optional path to the onnxruntime dynamic library.
/// If provided, it sets the ORT_DYLIB_PATH environment variable.
Future<void> initOrt({String? dylibPath}) =>
    RustLib.instance.api.crateApiPitchInitOrt(dylibPath: dylibPath);

/// Analyze an audio file and return a list of note events.
Future<List<NoteEvent>> analyzeAudioFile({
  required String audioPath,
  required String modelPath,
}) => RustLib.instance.api.crateApiPitchAnalyzeAudioFile(
  audioPath: audioPath,
  modelPath: modelPath,
);

/// Detect pitch from a real-time audio buffer.
Future<LivePitch> detectPitchLive({
  required List<double> samples,
  required double sampleRate,
}) => RustLib.instance.api.crateApiPitchDetectPitchLive(
  samples: samples,
  sampleRate: sampleRate,
);

class LivePitch {
  final double hz;
  final int midiNote;
  final double clarity;
  final double amplitude;

  const LivePitch({
    required this.hz,
    required this.midiNote,
    required this.clarity,
    required this.amplitude,
  });

  @override
  int get hashCode =>
      hz.hashCode ^ midiNote.hashCode ^ clarity.hashCode ^ amplitude.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LivePitch &&
          runtimeType == other.runtimeType &&
          hz == other.hz &&
          midiNote == other.midiNote &&
          clarity == other.clarity &&
          amplitude == other.amplitude;
}

class NoteEvent {
  final double startTime;
  final double duration;
  final int midiNote;
  final double confidence;

  const NoteEvent({
    required this.startTime,
    required this.duration,
    required this.midiNote,
    required this.confidence,
  });

  @override
  int get hashCode =>
      startTime.hashCode ^
      duration.hashCode ^
      midiNote.hashCode ^
      confidence.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NoteEvent &&
          runtimeType == other.runtimeType &&
          startTime == other.startTime &&
          duration == other.duration &&
          midiNote == other.midiNote &&
          confidence == other.confidence;
}
